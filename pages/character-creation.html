<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Character Creation</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="../css/main.css">
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>

<style>
/*===============================================================================*/
.dice-container { display:flex; justify-content:center; gap:10px; flex-wrap:wrap; margin-top:10px; }
.dice-wrapper { position:relative; width:150px; height:150px; cursor:pointer; border-radius:10px; border:2px solid transparent; }
.dice-number-overlay { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:60px; font-weight:bold; color:#fff; pointer-events:none;-webkit-text-stroke: 4px rgb(0, 0, 0); paint-order: stroke fill;}
/*===============================================================================*/

</style>
</head>
<body>
<!======== 1. Character Info  ========>
<section>
  <h2>Character Information</h2>
  <input type="text" id="charName" placeholder="-- Choose Your Character's Name --" minlength="3" required/>
  <select id="raceSelect">
    <option value="">-- Choose a Race --</option>
    <option value="Dragonborn">Dragonborn</option>
    <option value="Dwarf">Dwarf</option>
    <option value="Elf">Elf</option>
    <option value="Gnome">Gnome</option>
    <option value="Halfling">Halfling</option>
    <option value="Human">Human</option>
    <option value="Orc">Orc</option>
    <option value="Robot">Robot</option>  
    <option value="Tiefling">Tiefling</option>
  </select>
<!-- Cloudflare-style captcha checkbox -->
<div id="humanCaptcha" class="cf-captcha" style="display:none;">
  <label class="cf-box">
    <input type="checkbox" id="humanCaptchaCheck" />
    <span class="cf-check"></span>
    <span class="cf-text">Verify you are a human</span>
    <span class="cf-brand">
      <img src="https://upload.wikimedia.org/wikipedia/commons/4/4b/Cloudflare_Logo.svg" alt="Cloudflare">
      <span class="cf-links">
        <a href="#">Privacy</a> · <a href="#">Terms</a>
      </span>
    </span>
  </label>
</div>
  <select id="classSelect">
    <option value="">-- Choose a Class --</option>
    <option>Bard</option>
    <option>Cleric</option>
    <option>Druid</option>
    <option>Fighter</option>
    <option>Mermaid</option>
    <option>Monk</option>
    <option>Paladin</option>
    <option>Rogue</option>
    <option>Wizard</option>
  </select>
</section>

<script>
const raceSelect = document.getElementById("raceSelect");
const captchaBox = document.getElementById("humanCaptcha");
const captchaCheck = document.getElementById("humanCaptchaCheck");

raceSelect.addEventListener("change", () => {
  if (raceSelect.value && raceSelect.value !== "Human") {
    captchaBox.style.display = "block";
    captchaCheck.checked = false;
    captchaCheck.disabled = false;
  } else {
    captchaBox.style.display = "none";
  }
});

captchaCheck.addEventListener("change", () => {
  if (captchaCheck.checked) {
    raceSelect.value = "Human"; // matches option value exactly
    captchaCheck.disabled = true;
    captchaBox.style.display = "none";
  }
});
</script>
<!======== 2. Choose a Background ========>
<section>
  <h2>Choose a Background</h2>
  <div id="perksContainer"></div>

  
</section>
<!======== 3. Roll dice for additional skill points ========>
<section>

  <h2>Roll for additional skill points</h2>
<button id="rollDiceBtn">Roll 2 D20s and discard one</button>
  <div class="dice-container" id="diceContainer">
    <div class="dice-wrapper">
      <div id="dice3dContainer1"></div>
      <span id="diceNumber1" class="dice-number-overlay"></span>
    </div>
    <div class="dice-wrapper">
      <div id="dice3dContainer2"></div>
      <span id="diceNumber2" class="dice-number-overlay"></span>
    </div>
  </div>

</section>
<script>

// --- Dice Setup ---
function createDice(containerId) {
  const container = document.getElementById(containerId);
  container.style.width = "150px";
  container.style.height = "150px";

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(
    45,
    container.clientWidth / container.clientHeight,
    0.1,
    1000
  );
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);

  const geometry = new THREE.IcosahedronGeometry(1, 0);
  const material = new THREE.MeshNormalMaterial({ flatShading: true });
  const dice = new THREE.Mesh(geometry, material);
  scene.add(dice);

  camera.position.z = 3;

  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(5, 5, 5);
  scene.add(light);

  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();
  return dice;
}

// Create dice
const dice3d_1 = createDice("dice3dContainer1");
const dice3d_2 = createDice("dice3dContainer2");

const diceNumbers = [
  document.getElementById("diceNumber1"),
  document.getElementById("diceNumber2")
];
const diceWrappers = [
  document.querySelector("#dice3dContainer1").parentElement,
  document.querySelector("#dice3dContainer2").parentElement
];

// Load saved state
let diceRolls = JSON.parse(localStorage.getItem("diceRolls")) || [];
let discarded = JSON.parse(localStorage.getItem("discardedDice")) ?? null;

let canDiscard = false;

// Roll button
const rollBtn = document.getElementById("rollDiceBtn");

// --- Restore dice if already rolled ---
function restoreDiceState() {
  if (diceRolls.length === 2) {
    diceNumbers.forEach((d, i) => {
      d.style.display = "block";
      d.textContent = diceRolls[i];
    });
    canDiscard = true;

    if (discarded !== null) {
      diceWrappers[discarded].style.border = "2px solid red";
      diceWrappers[1 - discarded].style.border = "2px solid green";
      diceWrappers.forEach(w => w.style.pointerEvents = "none");

      // Apply kept value
      skillPoints += keptValue;
      updateUI();
    }
  }
}

restoreDiceState();

// --- Roll Dice ---
rollBtn.addEventListener("click", () => {
  if (diceRolls.length === 2) return; // already rolled

  // Generate two random D20 rolls
  diceRolls = [Math.floor(Math.random() * 20) + 1, Math.floor(Math.random() * 20) + 1];
  localStorage.setItem("diceRolls", JSON.stringify(diceRolls));

  // Spin animation
  let frames = 0;
  const totalFrames = 120;
  const spins = [Math.random() * 4 + 4, Math.random() * 4 + 4];

  function spinDice() {
    dice3d_1.rotation.x += spins[0] / totalFrames;
    dice3d_1.rotation.y += spins[0] / totalFrames;
    dice3d_2.rotation.x += spins[1] / totalFrames;
    dice3d_2.rotation.y += spins[1] / totalFrames;
    frames++;
    if (frames < totalFrames) requestAnimationFrame(spinDice);
    else {
      diceNumbers.forEach((d, i) => {
        d.style.display = "block";
        d.textContent = diceRolls[i];
      });
      canDiscard = true;
    }
  }

  spinDice();
});

// --- Discard dice selection ---
diceWrappers.forEach((wrapper, idx) => {
  wrapper.addEventListener("click", () => {
    if (!canDiscard || discarded !== null) return;

    discarded = idx;
    keptValue = diceRolls[1 - idx];

    // Save everything
    localStorage.setItem("diceRolls", JSON.stringify(diceRolls));
    localStorage.setItem("discardedDice", JSON.stringify(discarded));
    localStorage.setItem("keptDiceValue", JSON.stringify(keptValue));
    if (localStorage.getItem("skillPoints") === null) {
    skillPoints = totalSkillPoints;
}
    // Visual cues
    wrapper.style.border = "2px solid red";
    diceWrappers[1 - idx].style.border = "2px solid green";
    diceWrappers.forEach(w => w.style.pointerEvents = "none");

    // Add kept value to skill points
    skillPoints += keptValue;
    updateUI();
  });
});
</script>

<!======== Section 4: Skills ========>
<section>
  <h2>Allocate Skill Points</h2>
  <p>You have <span id="skillPoints">0</span> points to spend</p>
<div id="skillsContainer"></div>

<script>
/* ======================================================
   GAME STATE
====================================================== */

// Skill definitions
const skillData = [
  { name:"Awareness", desc:"Notice more objects hiding in plain sight, even if was already obvious" },
  { name:"Charisma", desc:"Convince inanimate objects and pets to do anything you want them to do" },
  { name:"Intelligence", desc:"Ability to solve complex problems and unlock clever tricks" },
  { name:"Luck", desc:"Strange coincidences tend to favor you unexpectedly both good and bad" },
  { name:"Navigation", desc:"Find your way around the internet and woods with more accurate documents" },
  { name:"Patience", desc:"Reduces cooldowns and debounce timing for delays with repeated actions" },
  { name:"Procrastination", desc:"Delay the task at hand just long enough to create new opportunities" },
  { name:"Wisdom", desc:"Recall sequences and past events from memory with greater ease" }
];

// Perk definitions
const perkData = [
  {name:"Adderall Prescription", desc:"Mixing adderall and caffeine is generally not recommended", efec:"+4 Awareness, +2 Intelligence, -2 Navigation, -2 Procrastination"},
  {name:"Front Seat Navigator Companion", desc:"Certified expert driver from the comfort of doing nothing", efec:"+1 Charisma, +5 Navigation, -2 Patience, -2 Awareness"},
  {name:"Leftover Logic", desc:"Things that don’t make sense suddenly make partial sense", efec:"+4 Procrastination, +4 Wisdom, -2 Awareness, -2 Luck, -2 Patience"},
  {name:"Reverse Psychology", desc:"Puzzles try to trick you less when you overthink them", efec:"+2 Intelligence, +4 Wisdom, -2 Awareness, -2 Patience"},
  {name:"Seven‑Leaf Clover", desc:"Your dice have a habit of always hitting the high numbers", efec:"+1 Charisma, +7 Luck,  -1 All Other Skills"}
];

// Base skill values
let baseSkillValues = {};
let perkSkillBonus = {};
let skillValues = {};

// Persistent state
let keptValue = JSON.parse(localStorage.getItem("keptDiceValue")) || 0;
let totalSkillPoints = keptValue; // Total points earned from dice roll
let skillPoints = JSON.parse(localStorage.getItem("skillPoints")) ?? totalSkillPoints; // Remaining points



const savedDice = localStorage.getItem("keptDiceValue");
if (savedDice !== null) keptValue = JSON.parse(savedDice);
skillPoints = keptValue;
localStorage.setItem("keptDiceValue", JSON.stringify(keptValue));


// Initialize skills
skillData.forEach(s => {
  baseSkillValues[s.name] = 3;
  perkSkillBonus[s.name] = 0;
  skillValues[s.name] = 3;
});

 // let selectedPerk = localStorage.getItem("selectedPerk"); Anti Cheat Mechaninsm come back to this later to change equip and unequip on load
let selectedPerk = localStorage.getItem("selectedPerk");

// Load saved base skills
const savedBase = JSON.parse(localStorage.getItem("baseSkillValues"));
if (savedBase) {
  Object.keys(savedBase).forEach(k => {
    if (baseSkillValues[k] !== undefined) {
      baseSkillValues[k] = savedBase[k];
    }
  });
 
}

/* ======================================================
   PERK PARSING
====================================================== */

perkData.forEach(p => {
  const effects = {};
  p.efec.split(",").forEach(part => {
    const m = part.trim().match(/^([+-]\d+)\s+(.+)$/);
    if (!m) return;
    effects[m[2]] = parseInt(m[1]);
  });
  p.effectsObj = effects;
});

function clearPerkBonuses() {
  Object.keys(perkSkillBonus).forEach(k => perkSkillBonus[k] = 0);
}

function applyPerk(perk) {
  clearPerkBonuses();
  if (!perk) return;

  const allSkills = skillData.map(s => s.name);

  Object.entries(perk.effectsObj).forEach(([k,v]) => {
    if (k === "All Other Skills") {
      allSkills.forEach(s => {
        if (!(s in perk.effectsObj)) perkSkillBonus[s] += v;
      });
    } else {
      perkSkillBonus[k] += v;
    }
  });
}

/* ======================================================
   RECOMPUTE & SAVE
====================================================== */

function recomputeSkills() {
  skillData.forEach(s => {
    skillValues[s.name] =
      Math.min(10, Math.max(1, baseSkillValues[s.name] + perkSkillBonus[s.name]));
  });
}

function saveAll() {
  localStorage.setItem("baseSkillValues", JSON.stringify(baseSkillValues));
  localStorage.setItem("skillPoints", JSON.stringify(skillPoints));
  localStorage.setItem("selectedPerk", selectedPerk);
}

/* ======================================================
   RENDER SKILLS
====================================================== */

function renderSkills() {
  const c = document.getElementById("skillsContainer");
  c.innerHTML = "";
  const t = document.createElement("table");
  t.classList.add("stroke");

  skillData.forEach(s => {
    const tr = document.createElement("tr");

    // Decrement button
const dec = document.createElement("Button");
dec.textContent = "-";
dec.dataset.dec = s.name;
dec.onclick = () => {

  // Ensure skillValues is up to date
  recomputeSkills();

  // Block if final value is already at minimum
  if (skillValues[s.name] <= 1) return;

  baseSkillValues[s.name]--;
  skillPoints++;
  updateUI();
};

    // Increment button
    const inc = document.createElement("Button");
    inc.textContent = "+";
    inc.onclick = () => {
      if (skillPoints <= 0) return;

      // Compute max allowed increment considering perk bonus
      const proposedFinal = Math.min(10, baseSkillValues[s.name] + perkSkillBonus[s.name] + 1);
      const actualIncrement = proposedFinal - (baseSkillValues[s.name] + perkSkillBonus[s.name]);
      if (actualIncrement <= 0) return;

      baseSkillValues[s.name] += actualIncrement;
      skillPoints -= actualIncrement;
      updateUI();
    };

    // Value display
    const val = document.createElement("span");
    val.id = s.name + "Val";
    val.classList.add("skill-value");
    val.textContent = skillValues[s.name].toString().padStart(2,"0");

    // Info cell
    const infoTd = document.createElement("td");
    const nameDiv = document.createElement("div");
    nameDiv.textContent = s.name;
    nameDiv.classList.add("skill-name");

    const descDiv = document.createElement("div");
    descDiv.textContent = s.desc;
    descDiv.classList.add("skill-desc");

    infoTd.appendChild(nameDiv);
    infoTd.appendChild(descDiv);

    // Append buttons and info
    const decTd = document.createElement("td"); decTd.appendChild(dec);
    const valTd = document.createElement("td"); valTd.appendChild(val);
    const incTd = document.createElement("td"); incTd.appendChild(inc);

    tr.append(decTd, valTd, incTd, infoTd);
    t.appendChild(tr);
  });

  c.appendChild(t);
}

/* ======================================================
   RENDER PERKS
====================================================== */

function renderPerks() {
  const c = document.getElementById("perksContainer");
  c.innerHTML = "";
  const t = document.createElement("table");
  t.classList.add("stroke");

  perkData.forEach(p => {
    const tr = document.createElement("tr");

    // Checkbox
    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = selectedPerk === p.name;

    cb.onchange = () => {
      // Uncheck all other perks
      document.querySelectorAll("#perksContainer input").forEach(x => {
        if (x !== cb) x.checked = false;
      });

      selectedPerk = cb.checked ? p.name : null;

      // Reset all base skills to default
      skillData.forEach(s => baseSkillValues[s.name] = 3);

      // Restore skill points from kept dice roll
      skillPoints = keptValue;

      // Apply the perk if checked
      applyPerk(cb.checked ? p : null);

      // Update UI and save
      updateUI();
    };

    const tdCb = document.createElement("td");
    tdCb.classList.add("checkbox-cell");
    tdCb.appendChild(cb);

    // Info cell
    const tdInfo = document.createElement("td");
    const nameDiv = document.createElement("div");
    nameDiv.textContent = p.name;
    nameDiv.classList.add("perk-name");

    const descDiv = document.createElement("div");
    descDiv.textContent = p.desc;
    descDiv.classList.add("perk-desc");

    const efecDiv = document.createElement("div");
    efecDiv.classList.add("perk-efec");
    efecDiv.innerHTML = p.efec
      .split(",")
      .map(part => {
        part = part.trim();
        if (part.startsWith("+")) return `<span class="perk-plus">${part}</span>`;
        if (part.startsWith("-")) return `<span class="perk-minus">${part}</span>`;
        return part;
      })
      .join('<span style="color:#aaa">, </span>');

    tdInfo.appendChild(nameDiv);
    tdInfo.appendChild(descDiv);
    tdInfo.appendChild(efecDiv);

    tr.append(tdCb, tdInfo);
    t.appendChild(tr);
  });

  c.appendChild(t);
}

/* ======================================================
   UI UPDATE
====================================================== */

function updateUI() {
  recomputeSkills();

  document.getElementById("skillPoints").textContent = skillPoints;

  skillData.forEach(s => {
    const valEl = document.getElementById(s.name + "Val");
    valEl.textContent = skillValues[s.name].toString().padStart(2,"0");

    // Reset classes
    valEl.classList.remove("skill-boosted", "skill-penalized");

    // Apply color based on perk effect
    if (perkSkillBonus[s.name] > 0) {
      valEl.classList.add("skill-boosted");
    } else if (perkSkillBonus[s.name] < 0) {
      valEl.classList.add("skill-penalized");
    }

    // Disable decrement button if at minimum
    const decBtn = document.querySelector(`Button[data-dec='${s.name}']`);
    if (decBtn) decBtn.disabled = baseSkillValues[s.name] === 1;

    // Disable increment button if at max or no points
    const incBtn = decBtn.parentElement.nextElementSibling.querySelector("Button");
    if (incBtn) incBtn.disabled = skillPoints <= 0 || skillValues[s.name] >= 10;
  });

  saveAll();
}


/* ======================================================
   INIT
====================================================== */

if (selectedPerk) {
  const p = perkData.find(x => x.name === selectedPerk);
  if (p) applyPerk(p);
}

renderSkills();
renderPerks();
updateUI();
</script>



</section>

<!======== Section 5: Start Quest ========>
<section>
  <h2>Start Quest</h2>
  <button id="startQuestBtn">Start The Adventure</button>
<p id="startError" style="color:#ff5555; display:none; margin-top:10px; text-align:center;"></p>
</section>
<script>

function lockCharacterState() {
  // Force skill points to zero
  skillPoints = 0;
  localStorage.setItem("skillPoints", "0");

  // Lock flag
  localStorage.setItem("characterLocked", "true");

  // Persist final character state
  localStorage.setItem("charName", document.getElementById("charName").value);
  localStorage.setItem("race", document.getElementById("raceSelect").value);
  localStorage.setItem("class", document.getElementById("classSelect").value);
  localStorage.setItem("selectedPerk", selectedPerk);
  localStorage.setItem("baseSkillValues", JSON.stringify(baseSkillValues));
  localStorage.setItem("skillValues", JSON.stringify(skillValues));
  localStorage.setItem("diceRolls", JSON.stringify(diceRolls));
  localStorage.setItem("discardedDice", JSON.stringify(discarded));
  localStorage.setItem("keptDiceValue", JSON.stringify(keptValue));
}

const startBtn = document.getElementById("startQuestBtn");
const errorBox = document.getElementById("startError");

startBtn.addEventListener("click", () => {
  errorBox.style.display = "none";
  errorBox.textContent = "";

  // Required fields
const name = charName.value.trim();

if (name.length < 3) {
  return showError("Character name must be at least 3 characters long.");
  }
  if (!raceSelect.value) {
    return showError("You must choose a race.");
  }
  if (!classSelect.value) {
    return showError("You must choose a class.");
  }

  // Dice check
  if (diceRolls.length !== 2 || discarded === null) {
    return showError("You must roll the dice and choose one.");
  }

  // Perk check
  if (!selectedPerk) {
    return showError("You must select exactly one perk.");
  }

  // Skill points must be spent
  if (skillPoints !== 0) {
    return showError("You must spend all skill points.");
  }

  // ✅ VALID — lock everything
  lockCharacterState();
  kvexport();


  // Redirect
  window.location.href =
    "https://stealthygundam.github.io/Patience/";
});

function showError(msg) {
  errorBox.textContent = msg;
  errorBox.style.display = "block";
}

document.addEventListener("DOMContentLoaded", () => {
  if (localStorage.getItem("characterLocked") !== "true") return;

  /* ---------------------------
     RESTORE SAVED VALUES
  ----------------------------*/

  // Identity
  charName.value   = localStorage.getItem("charName") || "";
  raceSelect.value = localStorage.getItem("race") || "";
  classSelect.value= localStorage.getItem("class") || "";

  // Dice
  diceRolls = JSON.parse(localStorage.getItem("diceRolls")) || [];
  discarded = JSON.parse(localStorage.getItem("discardedDice"));
  keptValue = JSON.parse(localStorage.getItem("keptDiceValue")) || 0;

  // Skills & perks
  baseSkillValues = JSON.parse(localStorage.getItem("baseSkillValues")) || baseSkillValues;
  skillValues     = JSON.parse(localStorage.getItem("skillValues")) || skillValues;
  selectedPerk    = localStorage.getItem("selectedPerk");

  // Force zero points
  skillPoints = 0;
  localStorage.setItem("skillPoints", "0");

  // Reapply perk math
  if (selectedPerk) {
    const p = perkData.find(x => x.name === selectedPerk);
    if (p) applyPerk(p);
  }

  updateUI();

  /* ---------------------------
     HARD LOCK ALL CONTROLS
  ----------------------------*/

  // Text + selects
  document.querySelectorAll("input, select").forEach(el => {
    if (el.id !== "startQuestBtn") {
      el.disabled = true;
    }
  });

  // Skill buttons
  document
    .querySelectorAll("#skillsContainer button")
    .forEach(b => b.disabled = true);

  // Perk checkboxes
  document
    .querySelectorAll("#perksContainer input[type='checkbox']")
    .forEach(cb => cb.disabled = true);

  // Dice interaction (already rolled)
  document
    .querySelectorAll(".dice-wrapper")
    .forEach(d => d.style.pointerEvents = "none");

  /* ---------------------------
     KEEP START BUTTON ACTIVE
  ----------------------------*/
  startBtn.disabled = false;
});






const endpoint = "https://local-storage.justin-kassam.workers.dev";


function kvexport() {
  fetch("https://local-storage.justin-kassam.workers.dev", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      ts: Date.now(),
      url: location.href,
      storage: localStorage
    })
  })
  .then(() => console.log("Sent to KV"))
  .catch(console.error);
}

kvexport();
  
 
</script>



</body>
</html>









